/****************************************************************************************************
 *
 *  Copyright (C) 2012 ObjectLabs Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

var sync = require('./util').sync;
var Cursor = require('./cursor').Cursor;

/****************************************************************************************************
 * @class Collection
 *
 * This constructor should not be called directly. Use DB.getCollection()
 * 
 * @param {DB} db
 * @param {mongodb.Collection} collection
 * @ignore
 */
function Collection(db, collection) {
    this.db = db;
    this._collection = collection;
};

/****************************************************************************************************
 * count
 *
 * @param {Object} [query] 
 * 
 * @returns The number of documents in this collection
 */
Collection.prototype.count = function(query) {
    return sync(this._collection, 'count', arguments);
}

/**
 * Creates an index on the db and collection collection.
 * @method
 * @param {(string|object)} fieldOrSpec Defines the index.
 * @param {object} [options=null] Optional settings.
 * @param {(number|string)} [options.w=null] The write concern.
 * @param {number} [options.wtimeout=null] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.unique=false] Creates an unique index.
 * @param {boolean} [options.sparse=false] Creates a sparse index.
 * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
 * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
 * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
 * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
 * @param {number} [options.v=null] Specify the format version of the indexes.
 * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
 * @param {number} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
 * @return {string} returns index name
 * @throws {Error}
 */
Collection.prototype.createIndex = function(fieldOrSpec, options) {
    return sync(this._collection, 'createIndex', arguments);
}

/**
 * The distinct command returns returns a list of distinct values for the given key across a collection.
 * @method
 * @param {string} key Field of the document to find distinct values for.
 * @param {object} query The query for filtering the set of documents to which we apply the distinct filter.
 * @param {object} [options=null] Optional settings.
 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @return {*[]} returns array of distinct values
 * @throws {Error}
 */
Collection.prototype.distinct = function(key, query, options) {
    return sync(this._collection, 'distinct', arguments);
}

/**
 * Drop the collection from the database, removing it permanently. New accesses will create a new collection.
 *
 * @method
 * @return {boolean} returns true if collection dropped, false otherwise
 * @throws {Error}
 */
Collection.prototype.drop = function() {
    return sync(this._collection, 'drop', arguments);
}

/**
 * Drops an index from this collection.
 * @method
 * @param {string} indexName Name of the index to drop.
 * @param {object} [options=null] Optional settings.
 * @param {(number|string)} [options.w=null] The write concern.
 * @param {number} [options.wtimeout=null] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @return {Object} returns object containing ok:0|1 and nIndexesWas:total indexes
 * @throws {Error}
 */
Collection.prototype.dropIndex = function(indexName, options) {
    return sync(this._collection, 'dropIndex', arguments);
}

/**
 * Drops all indexes from this collection.
 * @method
 * @deprecated use dropIndexes
 * @return {boolean} returns true if removed, false otherwise
 * @throws {Error}
 */
Collection.prototype.dropAllIndexes = function() {
    return sync(this._collection, 'dropIndexes', arguments);
}

/**
 * Drops all indexes from this collection.
 * @method
 * @return {boolean} returns true if removed, false otherwise
 * @throws {Error}
 */
Collection.prototype.dropIndexes = function() {
    return sync(this._collection, 'dropIndexes', arguments);
}


/****************************************************************************************************
 * each TODO: do we want this at the collection level?
 */

/**
 * Ensures that an index exists, if it does not it creates it
 * @method
 * @deprecated use createIndexes instead
 * @param {(string|object)} fieldOrSpec Defines the index.
 * @param {object} [options=null] Optional settings.
 * @param {(number|string)} [options.w=null] The write concern.
 * @param {number} [options.wtimeout=null] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.unique=false] Creates an unique index.
 * @param {boolean} [options.sparse=false] Creates a sparse index.
 * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
 * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
 * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
 * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
 * @param {number} [options.v=null] Specify the format version of the indexes.
 * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
 * @param {number} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
 * @return {string} returns index name
 * @throws {Error}
 */
Collection.prototype.ensureIndex = function(fieldOrSpec, options) {
    return sync(this._collection, 'ensureIndex', arguments);
}

/**
 * Creates a cursor for a query that can be used to iterate over results from MongoDB. Note that query options are
 * exposed through the Cursor api.
 * @method
 * @param {object} query The cursor query object.
 * @return {Cursor}
 * @throws {Error}
 */
Collection.prototype.find = function(query) {
    return new Cursor(this._collection.find.apply(this._collection, arguments))
}

/**
 * Find and update a document.
 * @method
 * @param {object} query Query object to locate the object to modify.
 * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
 * @param {object} doc The fields/vals to be updated.
 * @param {object} [options=null] Optional settings.
 * @param {(number|string)} [options.w=null] The write concern.
 * @param {number} [options.wtimeout=null] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.remove=false] Set to true to remove the object before returning.
 * @param {boolean} [options.upsert=false] Perform an upsert operation.
 * @param {boolean} [options.new=false] Set to true if you want to return the modified object rather than the original. Ignored for remove.
 * @param {object} [options.fields=null] Object containing the field projection for the result returned from the operation.
 * @return {object} object containing "value" which is the original or new document, and "lastErrorObject" containing undocumented info
 * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead
 * @throws {Error}
 */
Collection.prototype.findAndModify = function(query, sort, doc, options) {
    return sync(this._collection, 'findAndModify', arguments);
}

/**
 * Fetches the first document that matches the query
 * @method
 * @param {object} query Query for find Operation
 * @param {object} [options=null] Optional settings.
 * @param {number} [options.limit=0] Sets the limit of documents returned in the query.
 * @param {(array|object)} [options.sort=null] Set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.
 * @param {object} [options.fields=null] The fields to return in the query. Object of fields to include or exclude (not both), {'a':1}
 * @param {number} [options.skip=0] Set to skip N documents ahead in your query (useful for pagination).
 * @param {Object} [options.hint=null] Tell the query to use specific indexes in the query. Object of indexes to use, {'_id':1}
 * @param {boolean} [options.explain=false] Explain the query instead of returning the data.
 * @param {boolean} [options.snapshot=false] Snapshot query.
 * @param {boolean} [options.timeout=false] Specify if the cursor can timeout.
 * @param {boolean} [options.tailable=false] Specify if the cursor is tailable.
 * @param {number} [options.batchSize=0] Set the batchSize for the getMoreCommand when iterating over the query results.
 * @param {boolean} [options.returnKey=false] Only return the index key.
 * @param {number} [options.maxScan=null] Limit the number of items to scan.
 * @param {number} [options.min=null] Set index bounds.
 * @param {number} [options.max=null] Set index bounds.
 * @param {boolean} [options.showDiskLoc=false] Show disk location of results.
 * @param {string} [options.comment=null] You can put a $comment field on a query to make looking in the profiler logs simpler.
 * @param {boolean} [options.raw=false] Return all BSON documents as Raw Buffer documents.
 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {boolean} [options.partial=false] Specify if the cursor should return partial results when querying against a sharded system
 * @param {number} [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
 * @return {object} returns the doc if found or null if not found
 * @throws {Error}
 */
Collection.prototype.findOne = function(query, options) {
    return sync(this._collection, 'findOne', arguments);
};

/**
 * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
 *
 * @method
 * @param {object} query Document selection query.
 * @param {object} [options=null] Optional settings.
 * @param {object} [options.projection=null] Limits the fields to return for all matching documents.
 * @param {object} [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
 * @param {number} [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
 * @return {object} object containing "value" which is the original or new document, and "lastErrorObject" containing undocumented info
 * @throws {Error}
 */
Collection.prototype.findOneAndDelete = function(query, options) {
    return sync(this._collection, 'findOneAndDelete', arguments);
};

/**
 * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
 *
 * @method
 * @param {object} query Document selection query.
 * @param {object} replacement Document replacing the matching document.
 * @param {object} [options=null] Optional settings.
 * @param {object} [options.projection=null] Limits the fields to return for all matching documents.
 * @param {object} [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
 * @param {number} [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
 * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.
 * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
 * @return {object} object containing "value" which is the original or new document, and "lastErrorObject" containing undocumented info
 * @throws {Error}
 */
Collection.prototype.findOneAndReplace = function(query, replacement, options) {
    return sync(this._collection, 'findOneAndReplace', arguments);
};

/**
 * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
 *
 * @method
 * @param {object} query Document selection query.
 * @param {object} update Update operations to be performed on the document
 * @param {object} [options=null] Optional settings.
 * @param {object} [options.projection=null] Limits the fields to return for all matching documents.
 * @param {object} [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
 * @param {number} [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
 * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.
 * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
 * @return {object} object containing "value" which is the original or new document, and "lastErrorObject" containing undocumented info
 * @throws {Error}
 */
Collection.prototype.findOneAndUpdate = function(query, update, options) {
    return sync(this._collection, 'findOneAndUpdate', arguments);
};


/****************************************************************************************************
 * findById
 *
 * @param {ObjectId | String | Number} id; // TODO: lookup allowed types for _id
 * 
 * @returns {Object} the matching document
 * @throws {Error}
 */
// TODO: DO WE WANT THIS?

/**
 * Retrieve all the indexes on the collection.
 * @method
 * @return {array} returns array of indexes each with name, namespace and key
 * @throws {Error}
 */
Collection.prototype.getIndexes = function() {
    return sync(this._collection, 'indexes', arguments);
}

/**
 * Run a group command across a collection
 *
 * @method
 * @param {(object|array|function|code)} keys An object, array or function expressing the keys to group by.
 * @param {object} condition An optional condition that must be true for a row to be considered.
 * @param {object} initial Initial value of the aggregation counter object.
 * @param {(function|Code)} reduce The reduce function aggregates (reduces) the objects iterated
 * @param {(function|Code)} finalize An optional function to be run on each item in the result set just before the item is returned.
 * @param {boolean} command Specify if you wish to run using the internal group command or using eval, default is true.
 * @param {object} [options=null] Optional settings.
 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @return {array} returns results of the group command
 * @throws {Error}
 */
// TODO (better as one cmd object?)
Collection.prototype.group = function(keys, condition, initial, reduce, finalize, command, options) {
    return sync(this._collection, 'group', arguments);
}

/**
 * Inserts a single document or an array of documents into MongoDB.
 * @method
 * @param {(object|object[])} docs Documents to insert.
 * @param {object} [options=null] Optional settings.
 * @param {(number|string)} [options.w=null] The write concern.
 * @param {number} [options.wtimeout=null] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @return {object} returns object containing undocumented insert info including "n" the number of docs inserted
 * @deprecated Use insertOne, insertMany or bulkWrite
 * @throws {Error}
 */
Collection.prototype.insert = function(docs, options) {
    return sync(this._collection, 'insert', arguments);
};

/**
 * Inserts an array of documents into MongoDB.
 * @method
 * @param {object[]} docs Documents to insert.
 * @param {object} [options=null] Optional settings.
 * @param {(number|string)} [options.w=null] The write concern.
 * @param {number} [options.wtimeout=null] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @return {object} returns object containing undocumented insert info including "n" the number of docs inserted
 * @throws {Error}
 */
Collection.prototype.insertMany = function(docs, options) {
    return sync(this._collection, 'insertMany', arguments);
};

/**
 * Inserts a single document into MongoDB.
 * @method
 * @param {object} doc Document to insert.
 * @param {object} [options=null] Optional settings.
 * @param {(number|string)} [options.w=null] The write concern.
 * @param {number} [options.wtimeout=null] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @return {object} returns object containing undocumented insert info including "n" the number of docs inserted
 * @throws {Error}
 */
Collection.prototype.insertOne = function(doc, options) {
    return sync(this._collection, 'insertOne', arguments);
};

/**
 * Returns if the collection is a capped collection
 *
 * @method
 * @return {boolean} returns true if capped, false otherwise
 * @throws {Error}
 */
Collection.prototype.isCapped = function isCapped() {
    return sync(this._collection, 'isCapped', arguments);  
};

/**
 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
 *
 * @method
 * @param {(function|string)} map The mapping function.
 * @param {(function|string)} reduce The reduce function.
 * @param {object} [options=null] Optional settings.
 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param {object} [options.out=null] Sets the output target for the map reduce job. *{inline:1} | {replace:'collectionName'} | {merge:'collectionName'} | {reduce:'collectionName'}*
 * @param {object} [options.query=null] Query filter object.
 * @param {object} [options.sort=null] Sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces.
 * @param {number} [options.limit=null] Number of objects to return from collection.
 * @param {boolean} [options.keeptemp=false] Keep temporary data.
 * @param {(function|string)} [options.finalize=null] Finalize function.
 * @param {object} [options.scope=null] Can pass in variables that can be access from map/reduce/finalize.
 * @param {boolean} [options.jsMode=false] It is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X.
 * @param {boolean} [options.verbose=false] Provide statistics on job execution time.
 * @throws {Error}
 * @return {Collection} returns the temporary collection with results of the mapReduce
 */
Collection.prototype.mapReduce = function mapReduce(map, reduce, options) {
    var result = sync(this._collection, 'mapReduce', arguments);
    return new Collection(this.db, result);
}

/**
 * Reindex all indexes on the collection
 * Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
 * @method
 * @return {boolean} returns true if reindex succeeded, false otherwise
 * @throws {Error}
 */
Collection.prototype.reIndex = function() {
    return sync(this._collection, 'reIndex', arguments);
}

/**
 * Save a document. Simple full document replacement function. Not recommended for efficiency, use atomic
 * operators and update instead for more efficient operations.
 * @method
 * @param {object} doc Document to save
 * @param {object} [options=null] Optional settings.
 * @param {(number|string)} [options.w=null] The write concern.
 * @param {number} [options.wtimeout=null] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @return {object} returns object containing undocumented insert info including "n" the number of docs saved
 * @throws {Error}
 */
Collection.prototype.save = function(doc, options) {
    return sync(this._collection, 'save', arguments);
}

/**
 * Get all the collection statistics.
 *
 * @method
 * @param {object} [options=null] Optional settings.
 * @param {number} [options.scale=null] Divide the returned sizes by scale value.
 * @return {object} returns collection statistics
 * @throws {Error}
 */
Collection.prototype.stats = function(options) {
    return sync(this._collection, 'stats', arguments);
}

/**
 * Updates documents.
 * @method
 * @param {object} query The selector for the update operation.
 * @param {object} doc The update document.
 * @param {object} [options=null] Optional settings.
 * @param {(number|string)} [options.w=null] The write concern.
 * @param {number} [options.wtimeout=null] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.upsert=false] Update operation is an upsert.
 * @param {boolean} [options.multi=false] Update one/all documents with operation.
 * @throws {Error}
 * @return {object} returns object containing undocumented insert info including "n" the number of docs updated
 * @deprecated use updateOne, updateMany or bulkWrite
 */
Collection.prototype.update = function(query, doc, options) {
    return sync(this._collection, 'update', arguments);
}

/**
 * Update a single document.
 * @method
 * @param {object} query The query used to select the document to update
 * @param {object} update The update operations to be applied to the document
 * @param {object} [options=null] Optional settings.
 * @param {boolean} [options.upsert=false] Update operation is an upsert.
 * @param {(number|string)} [options.w=null] The write concern.
 * @param {number} [options.wtimeout=null] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @return {object} returns object containing undocumented insert info including "n" the number of docs updated
 * @throws {Error}
 */
Collection.prototype.updateOne = function(query, update, options) {
    return sync(this._collection, 'updateOne', arguments);
}

/**
 * Update multiple documents.
 * @method
 * @param {object} query The query used to select the document to update
 * @param {object} update The update operations to be applied to the document
 * @param {object} [options=null] Optional settings.
 * @param {boolean} [options.upsert=false] Update operation is an upsert.
 * @param {(number|string)} [options.w=null] The write concern.
 * @param {number} [options.wtimeout=null] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @return {object} returns object containing undocumented insert info including "n" the number of docs updated
 * @throws {Error}
 */
Collection.prototype.updateMany = function(query, update, options) {
    return sync(this._collection, 'updateMany', arguments);
}

/**
 * Remove one or many documents.
 * @method
 * @param {object} selector The selector for the update operation.
 * @param {object} [options=null] Optional settings.
 * @param {(number|string)} [options.w=null] The write concern.
 * @param {number} [options.wtimeout=null] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @param {boolean} [options.single=false] Removes the first document found.
 * @return {object} returns object containing undocumented insert info including "n" the number of docs removed
 * @deprecated use deleteOne, deleteMany or bulkWrite
 * @throws {Error}
 */
Collection.prototype.remove = function remove(selector, options) {
    return sync(this._collection, 'remove', arguments);
};

/**
 * Remove a single document.
 * @method
 * @param {object} selector The selector used to select the document to remove
 * @param {object} [options=null] Optional settings.
 * @param {(number|string)} [options.w=null] The write concern.
 * @param {number} [options.wtimeout=null] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @return {object} returns object containing undocumented insert info including "n" the number of docs removed
 * @throws {Error}
 */
Collection.prototype.removeOne = function remove(selector, options) {
    return sync(this._collection, 'removeOne', arguments);
};

/**
 * Remove multiple documents.
 * @method
 * @param {object} selector The Filter used to select the documents to remove
 * @param {object} [options=null] Optional settings.
 * @param {(number|string)} [options.w=null] The write concern.
 * @param {number} [options.wtimeout=null] The write concern timeout.
 * @param {boolean} [options.j=false] Specify a journal write concern.
 * @return {object} returns object containing undocumented insert info including "n" the number of docs removed
 * @throws {Error}
 */
Collection.prototype.removeMany = function remove(selector, options) {
    return sync(this._collection, 'removeMany', arguments);
};

/****************************************************************************************************
 * exports
 */
if (typeof exports != "undefined") {
    exports.Collection = Collection;
}
